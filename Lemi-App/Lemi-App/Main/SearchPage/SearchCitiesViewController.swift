//
//  SearchCitiesViewController.swift
//  Lemi-App
//
//  Created by Xander Mercado on 3/19/20.
//  Copyright (c) 2020 Xander Mercado. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol SearchCitiesViewControllerProtocol: class {
    func selectCity(city: City)
}

protocol SearchCitiesDisplayLogic: class {
    func displayCities(response: SearchCitiesModel.Response)
}

class SearchCitiesViewController: UIViewController, SearchCitiesDisplayLogic {
    var interactor: SearchCitiesBusinessLogic?
    var router: (NSObjectProtocol & SearchCitiesRoutingLogic)?
    
    weak var delegate: SearchCitiesViewControllerProtocol?
    
    lazy var myView: SearchCitiesView = {
        let view = SearchCitiesView()
        view.myTable.delegate = self
        view.myTable.dataSource = self
        view.translatesAutoresizingMaskIntoConstraints = false
        return view
    }()
    
    // MARK: Setup
    
    private func setupView() {
        view.backgroundColor = .white
        
        view.addSubview(myView)
        view.addConstraint(NSLayoutConstraint(
            item: myView,
            attribute: .top,
            relatedBy: .equal,
            toItem: view,
            attribute: .top,
            multiplier: 1,
            constant: 0))
        if #available(iOS 11.0, *) {
            view.addConstraint(NSLayoutConstraint(
                item: myView,
                attribute: .bottom,
                relatedBy: .equal,
                toItem: view.safeAreaLayoutGuide,
                attribute: .bottom,
                multiplier: 1,
                constant: 0))
        } else {
            view.addConstraint(NSLayoutConstraint(
                item: myView,
                attribute: .bottom,
                relatedBy: .equal,
                toItem: view,
                attribute: .bottom,
                multiplier: 1,
                constant: 0))
        }
        view.addConstraint(NSLayoutConstraint(
            item: myView,
            attribute: .trailing,
            relatedBy: .equal,
            toItem: view,
            attribute: .trailing,
            multiplier: 1,
            constant: 0))
        view.addConstraint(NSLayoutConstraint(
            item: myView,
            attribute: .width,
            relatedBy: .equal,
            toItem: view,
            attribute: .width,
            multiplier: 1,
            constant: 0))
    }
    
    private func configureView() {
        let viewController = self
        let interactor = SearchCitiesInteractor()
        let presenter = SearchCitiesPresenter()
        let router = SearchCitiesRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
    }
    
    // MARK: View lifecycle
    
    override func viewDidLoad() {
        super.viewDidLoad()
        configureView()
        setupView()
        setupNavigationBar()
        setupDefault()
    }
    
    private func setupDefault() {
        fetchCities()
    }
    
    func setupNavigationBar() {
        self.navigationController?.isNavigationBarHidden = false
        let backIcon = UIImage(named: "back")?.withRenderingMode(.alwaysTemplate)
        let backButton = UIBarButtonItem(image: backIcon, style: .plain, target: self, action: #selector(handleBack))
        backButton.tintColor = .black
        
        let searchBar = self.myView.searchBar
        searchBar.delegate = self
        
        searchBar.placeholder = "Search for a city"
        searchBar.barTintColor = .clear
        
        if let textfield = searchBar.value(forKey: "searchField") as? UITextField {
            if let backgroundview = textfield.subviews.first {
                backgroundview.backgroundColor = .clear
                textfield.textColor = .black
                textfield.backgroundColor = .clear
            }
        }
        
        let leftNavBarButton = UIBarButtonItem(customView: searchBar)
        self.navigationItem.leftBarButtonItems = [backButton, leftNavBarButton]
    }
    
    // MARK: Event Handling
    
    func fetchCities() {
        let request = myView.requestModel
        interactor?.fetchCities(request: request)
    }
    
    @objc func handleBack() {
        let vcCount = navigationController?.viewControllers.count ?? 0
        if vcCount >= 2 {
            self.navigationController?.popViewController(animated: true)
        } else {
            self.navigationController?.dismiss(animated: true, completion: nil)
        }
    }
    
    // MARK: Display Logic
    func displayCities(response: SearchCitiesModel.Response) {
        if response.error == false {
            myView.viewModel.cities = response.cities
            if response.cities?.count == 0 {
                self.myView.myTable.isHidden = true
            } else {
                self.myView.myTable.isHidden = false
            }
            
            DispatchQueue.main.async {
                self.myView.myTable.reloadData()
            }
        } else {
            self.myView.myTable.isHidden = true
        }
    }
}

extension SearchCitiesViewController: UISearchResultsUpdating, UISearchBarDelegate {
    func updateSearchResults(for searchController: UISearchController) {
        
    }
    
    func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) {
        myView.requestModel.q = searchText
        fetchCities()
    }
}

extension SearchCitiesViewController: UITableViewDelegate, UITableViewDataSource {
    
    func numberOfSections(in tableView: UITableView) -> Int {
        return 1
    }
    
    func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return myView.viewModel.cities?.count ?? 0
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        let cell = tableView.dequeueReusableCell(withIdentifier: "cell", for: indexPath) as! SearchCitiesTableViewCell
        cell.cellDetails = myView.viewModel.cities?[indexPath.row]
        cell.selectionStyle = .none
        return cell
    }
    
    func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) {
        self.myView.searchBar.endEditing(true)
        
        let city = myView.viewModel.cities?[indexPath.row]
        
        if let selectedCity = city {
            self.delegate?.selectCity(city: selectedCity)
            handleBack()
        }
    }
    
    func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -> CGFloat {
        return 80
    }
    
    func scrollViewWillBeginDragging(_ scrollView: UIScrollView) {
        self.myView.searchBar.endEditing(true)
    }
}
